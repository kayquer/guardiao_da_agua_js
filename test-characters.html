<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test 3D Characters</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            color: white;
        }
        h1 {
            text-align: center;
        }
        .container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .character-box {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        canvas {
            width: 300px;
            height: 300px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        h2 {
            margin-top: 10px;
            color: #4a9eff;
        }
        #log {
            margin-top: 30px;
            background: #000;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log-line {
            margin: 2px 0;
        }
        .log-success { color: #00ff88; }
        .log-error { color: #ff4444; }
        .log-warning { color: #ffaa00; }
        .log-info { color: #4a9eff; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <h1>üéÆ Test 3D Characters - Guardi√£o da √Ågua</h1>
    
    <div class="container">
        <div class="character-box">
            <canvas id="canvas-claudia"></canvas>
            <h2>üë©‚Äçüî¨ Claudia</h2>
        </div>
        <div class="character-box">
            <canvas id="canvas-fish"></canvas>
            <h2>üêü Gil (Peixe)</h2>
        </div>
        <div class="character-box">
            <canvas id="canvas-frog"></canvas>
            <h2>üê∏ Dr. Sapo</h2>
        </div>
    </div>

    <div id="log"></div>

    <script>
        // Logging system
        const logContainer = document.getElementById('log');
        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(line);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(message);
        }

        // Character configurations
        const characters = [
            {
                name: 'Claudia',
                canvas: 'canvas-claudia',
                modelFolder: 'models/Characters/girl-reading-a-book-icon-obj/',
                modelFile: 'girl-reading-a-book-icon.obj',
                texturePath: 'models/Characters/girl-reading-a-book-icon-obj/textures/',
                texturePrefix: 'girl-reading-a-book-icon-001-'
            },
            {
                name: 'Gil (Fish)',
                canvas: 'canvas-fish',
                modelFolder: 'models/Characters/fish-icon/',
                modelFile: 'fish-icon.obj',
                texturePath: 'models/Characters/fish-icon/textures/',
                texturePrefix: 'fish-icon-003-'
            },
            {
                name: 'Dr. Sapo',
                canvas: 'canvas-frog',
                modelFolder: 'models/Characters/frog-icon-obj/',
                modelFile: 'frog-icon.obj',
                texturePath: 'models/Characters/frog-icon-obj/textures/',
                texturePrefix: 'frog-icon-001-'
            }
        ];

        // Load each character
        characters.forEach(char => loadCharacter(char));

        async function loadCharacter(config) {
            log(`üîÑ Loading ${config.name}...`, 'info');
            
            const canvas = document.getElementById(config.canvas);
            const engine = new BABYLON.Engine(canvas, true);
            
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.2, 0.2, 0.25, 1);

            // Camera
            const camera = new BABYLON.ArcRotateCamera(
                'camera',
                Math.PI / 2,
                Math.PI / 2.5,
                4,
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 2;
            camera.upperRadiusLimit = 8;

            // Lighting
            const light1 = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 1.2;
            
            const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(-1, -2, -1), scene);
            light2.intensity = 0.8;

            // Environment
            try {
                const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
                    "https://assets.babylonjs.com/environments/environmentSpecular.env",
                    scene
                );
                scene.environmentTexture = hdrTexture;
                scene.environmentIntensity = 0.5;
            } catch (e) {
                log(`‚ö†Ô∏è ${config.name}: Could not load HDR environment`, 'warning');
            }

            // Load model
            try {
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    '',
                    config.modelFolder,
                    config.modelFile,
                    scene
                );

                log(`‚úÖ ${config.name}: Loaded ${result.meshes.length} meshes`, 'success');

                // List all meshes
                result.meshes.forEach((mesh, idx) => {
                    log(`  - Mesh ${idx}: ${mesh.name}`, 'info');
                });

                // Filter renderable meshes
                const meshes = result.meshes.filter(m => m.name !== '__root__' && m instanceof BABYLON.Mesh);
                log(`üìä ${config.name}: ${meshes.length} renderable meshes`, 'info');

                // Auto-scale and center
                if (meshes.length > 0) {
                    let min = new BABYLON.Vector3(Infinity, Infinity, Infinity);
                    let max = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity);

                    meshes.forEach(mesh => {
                        mesh.computeWorldMatrix(true);
                        const boundingInfo = mesh.getBoundingInfo();
                        min = BABYLON.Vector3.Minimize(min, boundingInfo.boundingBox.minimumWorld);
                        max = BABYLON.Vector3.Maximize(max, boundingInfo.boundingBox.maximumWorld);
                    });

                    const center = BABYLON.Vector3.Center(min, max);
                    const size = max.subtract(min);
                    const maxDimension = Math.max(size.x, size.y, size.z);
                    const scale = 2 / maxDimension;

                    const parent = new BABYLON.TransformNode('parent', scene);
                    result.meshes.forEach(mesh => {
                        if (mesh.parent === null) mesh.parent = parent;
                    });

                    parent.scaling = new BABYLON.Vector3(scale, scale, scale);
                    parent.position = center.scale(scale).negate();

                    log(`üìê ${config.name}: Scale=${scale.toFixed(4)}, Center=${center.toString()}`, 'info');
                }

                // Apply PBR textures
                await applyPBRTextures(meshes, config, scene);

            } catch (error) {
                log(`‚ùå ${config.name}: Error loading model - ${error.message}`, 'error');
                console.error(error);
            }

            // Render loop
            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());
        }

        async function applyPBRTextures(meshes, config, scene) {
            log(`üé® ${config.name}: Applying PBR textures...`, 'info');

            try {
                // Dispose old materials
                meshes.forEach(mesh => {
                    if (mesh.material) {
                        mesh.material.dispose();
                        mesh.material = null;
                    }
                });

                // Create PBR material
                const pbr = new BABYLON.PBRMaterial('pbrMat', scene);

                // Load textures
                const textures = [
                    { name: 'Albedo', file: 'col-metalness-4k.png', prop: 'albedoTexture' },
                    { name: 'Normal', file: 'nrm-metalness-4k.png', prop: 'bumpTexture' },
                    { name: 'Roughness', file: 'roughness-metalness-4k.png', prop: 'metallicTexture' },
                    { name: 'AO', file: 'ao-metalness-4k.png', prop: 'ambientTexture' }
                ];

                for (const tex of textures) {
                    try {
                        const texture = new BABYLON.Texture(
                            config.texturePath + config.texturePrefix + tex.file,
                            scene
                        );
                        pbr[tex.prop] = texture;
                        log(`  ‚úì ${config.name}: ${tex.name} loaded`, 'success');
                    } catch (e) {
                        log(`  ‚úó ${config.name}: ${tex.name} failed - ${e.message}`, 'error');
                    }
                }

                // Configure PBR
                pbr.useRoughnessFromMetallicTextureGreen = true;
                pbr.useMetallnessFromMetallicTextureBlue = false;
                pbr.metallic = 0.0;
                pbr.roughness = 1.0;
                pbr.albedoColor = new BABYLON.Color3(1, 1, 1);

                // Apply to meshes
                meshes.forEach(mesh => mesh.material = pbr);
                log(`‚úÖ ${config.name}: PBR material applied to ${meshes.length} meshes`, 'success');

            } catch (error) {
                log(`‚ùå ${config.name}: PBR error - ${error.message}`, 'error');
                
                // Fallback
                const fallback = new BABYLON.StandardMaterial('fallback', scene);
                fallback.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.7);
                meshes.forEach(mesh => mesh.material = fallback);
                log(`‚ö†Ô∏è ${config.name}: Using fallback material`, 'warning');
            }
        }
    </script>
</body>
</html>
