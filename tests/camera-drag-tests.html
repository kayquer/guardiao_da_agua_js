<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Drag Functionality Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-pending {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        #gameFrame {
            width: 100%;
            height: 600px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .test-log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>üß™ Camera Drag Functionality Tests</h1>
    <p>Comprehensive unit tests for camera left-click drag functionality to prevent blue screen crashes.</p>

    <div class="test-container">
        <h2>Test Environment</h2>
        <button onclick="loadGame()">Load Game</button>
        <button onclick="runAllTests()" id="runTestsBtn" disabled>Run All Tests</button>
        <button onclick="clearResults()">Clear Results</button>
        
        <div id="gameContainer" style="margin-top: 20px;">
            <iframe id="gameFrame" src="../index.html" style="display: none;"></iframe>
        </div>
    </div>

    <div class="test-container">
        <h2>Test Results</h2>
        <div id="testResults"></div>
    </div>

    <div class="test-container">
        <h2>Test Log</h2>
        <div id="testLog" class="test-log"></div>
    </div>

    <script>
        let gameWindow = null;
        let testResults = [];
        let currentTest = 0;

        function log(message) {
            const logDiv = document.getElementById('testLog');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function loadGame() {
            log('üéÆ Loading game for testing...');
            const gameFrame = document.getElementById('gameFrame');
            gameFrame.style.display = 'block';
            
            gameFrame.onload = function() {
                gameWindow = gameFrame.contentWindow;
                log('‚úÖ Game loaded successfully');
                document.getElementById('runTestsBtn').disabled = false;
                
                // Wait for game to fully initialize
                setTimeout(() => {
                    if (gameWindow.gameManager) {
                        log('‚úÖ GameManager detected and ready');
                    } else {
                        log('‚ùå GameManager not found - tests may fail');
                    }
                }, 3000);
            };
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('testLog').innerHTML = '';
            testResults = [];
            currentTest = 0;
        }

        function addTestResult(testName, passed, message) {
            const result = {
                name: testName,
                passed: passed,
                message: message,
                timestamp: new Date().toISOString()
            };
            testResults.push(result);

            const resultsDiv = document.getElementById('testResults');
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            resultDiv.innerHTML = `
                <strong>${testName}</strong><br>
                ${passed ? '‚úÖ PASS' : '‚ùå FAIL'}: ${message}
            `;
            resultsDiv.appendChild(resultDiv);
        }

        async function runAllTests() {
            log('üß™ Starting comprehensive camera drag tests...');
            clearResults();
            
            if (!gameWindow || !gameWindow.gameManager) {
                addTestResult('Environment Check', false, 'Game not loaded or GameManager not available');
                return;
            }

            const tests = [
                testCameraStateInitialization,
                testLeftClickDragDetection,
                testObjectSelectionBlocking,
                testCameraPanningState,
                testEventHandlingOrder,
                testDesktopCameraDrag,
                testMobileCameraDrag,
                testBuildingPlacementBlocking,
                testSceneStability,
                testMemoryLeaks
            ];

            for (let i = 0; i < tests.length; i++) {
                currentTest = i + 1;
                log(`üîç Running test ${currentTest}/${tests.length}: ${tests[i].name}`);
                
                try {
                    await tests[i]();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait between tests
                } catch (error) {
                    log(`‚ùå Test ${tests[i].name} threw an error: ${error.message}`);
                    addTestResult(tests[i].name, false, `Test threw an error: ${error.message}`);
                }
            }

            // Summary
            const passedTests = testResults.filter(r => r.passed).length;
            const totalTests = testResults.length;
            log(`üéØ Test Summary: ${passedTests}/${totalTests} tests passed`);
            
            if (passedTests === totalTests) {
                log('üéâ ALL TESTS PASSED! Camera drag functionality is working correctly.');
            } else {
                log('‚ùå Some tests failed. Camera drag functionality needs attention.');
            }
        }

        // Test 1: Camera State Initialization
        async function testCameraStateInitialization() {
            const gm = gameWindow.gameManager;
            
            if (!gm.isometricCameraState) {
                addTestResult('Camera State Initialization', false, 'isometricCameraState not found');
                return;
            }

            const state = gm.isometricCameraState;
            const hasRequiredProperties = 
                state.hasOwnProperty('isPanning') &&
                state.hasOwnProperty('leftMouseDown') &&
                state.hasOwnProperty('mouseDownTime') &&
                state.hasOwnProperty('mouseDownPosition');

            addTestResult('Camera State Initialization', hasRequiredProperties, 
                hasRequiredProperties ? 'All required camera state properties present' : 'Missing required camera state properties');
        }

        // Test 2: Left Click Drag Detection
        async function testLeftClickDragDetection() {
            const gm = gameWindow.gameManager;
            const canvas = gameWindow.document.querySelector('#game-canvas');
            
            if (!canvas) {
                addTestResult('Left Click Drag Detection', false, 'Game canvas not found');
                return;
            }

            // Reset camera state
            gm.isometricCameraState.isPanning = false;
            gm.isometricCameraState.leftMouseDown = false;

            // Simulate left mouse down on terrain
            const mouseDownEvent = new gameWindow.MouseEvent('mousedown', {
                button: 0,
                clientX: 400,
                clientY: 300,
                bubbles: true
            });

            canvas.dispatchEvent(mouseDownEvent);

            // Check if camera panning state was set
            const isPanningSet = gm.isometricCameraState.isPanning;
            const isLeftMouseDownSet = gm.isometricCameraState.leftMouseDown;

            addTestResult('Left Click Drag Detection', isPanningSet && isLeftMouseDownSet,
                `Camera panning state: ${isPanningSet}, Left mouse down: ${isLeftMouseDownSet}`);
        }

        // Test 3: Object Selection Blocking During Camera Operations
        async function testObjectSelectionBlocking() {
            const gm = gameWindow.gameManager;
            
            // Set camera panning state
            gm.isometricCameraState.isPanning = true;
            gm.isometricCameraState.leftMouseDown = true;

            // Try to trigger object selection (this should be blocked)
            let objectSelectionTriggered = false;
            const originalSelectObject = gm.selectObject;
            gm.selectObject = function() {
                objectSelectionTriggered = true;
                originalSelectObject.apply(this, arguments);
            };

            // Simulate pointer down event that would normally trigger object selection
            const mockPointerInfo = {
                pickInfo: {
                    hit: true,
                    pickedMesh: { name: 'terrain' },
                    pickedPoint: { x: 0, y: 0, z: 0 }
                },
                event: { button: 0, clientX: 400, clientY: 300 }
            };

            gm.handlePointerDown(mockPointerInfo);

            // Restore original method
            gm.selectObject = originalSelectObject;

            // Reset camera state
            gm.isometricCameraState.isPanning = false;
            gm.isometricCameraState.leftMouseDown = false;

            addTestResult('Object Selection Blocking', !objectSelectionTriggered,
                objectSelectionTriggered ? 'Object selection was not blocked during camera panning' : 'Object selection correctly blocked during camera panning');
        }

        // Test 4: Camera Panning State Management
        async function testCameraPanningState() {
            const gm = gameWindow.gameManager;
            
            // Reset state
            gm.isometricCameraState.isPanning = false;
            gm.isometricCameraState.leftMouseDown = false;

            // Test pointer down on terrain
            const mockPointerInfo = {
                pickInfo: {
                    hit: true,
                    pickedMesh: { name: 'terrain' },
                    pickedPoint: { x: 0, y: 0, z: 0 }
                },
                event: { button: 0, clientX: 400, clientY: 300 }
            };

            gm.handlePointerDown(mockPointerInfo);

            const panningStateSet = gm.isometricCameraState.isPanning;
            const leftMouseDownSet = gm.isometricCameraState.leftMouseDown;

            addTestResult('Camera Panning State Management', panningStateSet && leftMouseDownSet,
                `Panning state correctly set: ${panningStateSet}, Left mouse down: ${leftMouseDownSet}`);
        }

        // Test 5: Event Handling Order
        async function testEventHandlingOrder() {
            const gm = gameWindow.gameManager;
            const canvas = gameWindow.document.querySelector('#game-canvas');
            
            if (!canvas) {
                addTestResult('Event Handling Order', false, 'Game canvas not found');
                return;
            }

            let eventOrder = [];
            
            // Monitor pointer events
            const originalHandlePointerDown = gm.handlePointerDown;
            gm.handlePointerDown = function(pointerInfo) {
                eventOrder.push('pointerDown');
                return originalHandlePointerDown.call(this, pointerInfo);
            };

            // Monitor mouse events
            const originalHandleIsometricMouseDown = gm.handleIsometricMouseDown;
            gm.handleIsometricMouseDown = function(event) {
                eventOrder.push('mouseDown');
                return originalHandleIsometricMouseDown.call(this, event);
            };

            // Reset state
            gm.isometricCameraState.isPanning = false;
            gm.isometricCameraState.leftMouseDown = false;

            // Trigger mouse down event
            const mouseDownEvent = new gameWindow.MouseEvent('mousedown', {
                button: 0,
                clientX: 400,
                clientY: 300,
                bubbles: true
            });

            canvas.dispatchEvent(mouseDownEvent);

            // Wait for events to process
            await new Promise(resolve => setTimeout(resolve, 100));

            // Restore original methods
            gm.handlePointerDown = originalHandlePointerDown;
            gm.handleIsometricMouseDown = originalHandleIsometricMouseDown;

            const correctOrder = eventOrder.length > 0;
            addTestResult('Event Handling Order', correctOrder,
                `Event order: ${eventOrder.join(' -> ')}`);
        }

        // Additional tests will be added in the next part...
        
        // Test 6: Desktop Camera Drag
        async function testDesktopCameraDrag() {
            // Simulate desktop viewport
            gameWindow.resizeTo(1280, 720);
            await simulateCameraDrag('Desktop Camera Drag', 640, 360, 800, 500);
        }

        // Test 7: Mobile Camera Drag  
        async function testMobileCameraDrag() {
            // Simulate mobile viewport
            gameWindow.resizeTo(375, 667);
            await simulateCameraDrag('Mobile Camera Drag', 200, 300, 300, 400);
        }

        async function simulateCameraDrag(testName, startX, startY, endX, endY) {
            const gm = gameWindow.gameManager;
            const canvas = gameWindow.document.querySelector('#game-canvas');
            
            if (!canvas) {
                addTestResult(testName, false, 'Game canvas not found');
                return;
            }

            // Reset state
            gm.isometricCameraState.isPanning = false;
            gm.isometricCameraState.leftMouseDown = false;

            let blueScreenDetected = false;
            let sceneStable = true;

            try {
                // Mouse down
                const mouseDown = new gameWindow.MouseEvent('mousedown', {
                    button: 0, clientX: startX, clientY: startY, bubbles: true
                });
                canvas.dispatchEvent(mouseDown);

                await new Promise(resolve => setTimeout(resolve, 50));

                // Mouse move
                const mouseMove = new gameWindow.MouseEvent('mousemove', {
                    button: 0, clientX: endX, clientY: endY, bubbles: true
                });
                gameWindow.document.dispatchEvent(mouseMove);

                await new Promise(resolve => setTimeout(resolve, 50));

                // Mouse up
                const mouseUp = new gameWindow.MouseEvent('mouseup', {
                    button: 0, clientX: endX, clientY: endY, bubbles: true
                });
                gameWindow.document.dispatchEvent(mouseUp);

                await new Promise(resolve => setTimeout(resolve, 100));

                // Check scene stability
                if (gm.scene && gm.camera) {
                    const target = gm.camera.getTarget();
                    sceneStable = !isNaN(target.x) && !isNaN(target.y) && !isNaN(target.z) && 
                                 gm.scene.isReady() && !gm.scene.isDisposed;
                }

            } catch (error) {
                blueScreenDetected = true;
                sceneStable = false;
            }

            addTestResult(testName, !blueScreenDetected && sceneStable,
                `Blue screen: ${blueScreenDetected}, Scene stable: ${sceneStable}`);
        }

        // Test 8: Building Placement Blocking
        async function testBuildingPlacementBlocking() {
            const gm = gameWindow.gameManager;
            
            // Set camera panning state
            gm.isometricCameraState.isPanning = true;
            gm.buildMode = true;
            gm.currentBuildingType = 'water_pump';

            let buildingPlacementTriggered = false;
            if (gm.buildingSystem && gm.buildingSystem.placeBuildingAt) {
                const originalPlaceBuilding = gm.buildingSystem.placeBuildingAt;
                gm.buildingSystem.placeBuildingAt = function() {
                    buildingPlacementTriggered = true;
                    return originalPlaceBuilding.apply(this, arguments);
                };

                // Try to trigger building placement (should be blocked)
                const mockPointerInfo = {
                    pickInfo: {
                        hit: true,
                        pickedMesh: { name: 'terrain' },
                        pickedPoint: { x: 0, y: 0, z: 0 }
                    },
                    event: { button: 0, clientX: 400, clientY: 300 }
                };

                gm.handlePointerDown(mockPointerInfo);

                // Restore original method
                gm.buildingSystem.placeBuildingAt = originalPlaceBuilding;
            }

            // Reset state
            gm.isometricCameraState.isPanning = false;
            gm.buildMode = false;
            gm.currentBuildingType = null;

            addTestResult('Building Placement Blocking', !buildingPlacementTriggered,
                buildingPlacementTriggered ? 'Building placement was not blocked during camera panning' : 'Building placement correctly blocked during camera panning');
        }

        // Test 9: Scene Stability
        async function testSceneStability() {
            const gm = gameWindow.gameManager;
            
            if (!gm.scene || !gm.camera) {
                addTestResult('Scene Stability', false, 'Scene or camera not found');
                return;
            }

            const sceneReady = gm.scene.isReady();
            const sceneNotDisposed = !gm.scene.isDisposed;
            const cameraValid = gm.camera && typeof gm.camera.getTarget === 'function';
            
            let cameraTargetValid = false;
            if (cameraValid) {
                try {
                    const target = gm.camera.getTarget();
                    cameraTargetValid = !isNaN(target.x) && !isNaN(target.y) && !isNaN(target.z);
                } catch (error) {
                    cameraTargetValid = false;
                }
            }

            const stable = sceneReady && sceneNotDisposed && cameraValid && cameraTargetValid;
            addTestResult('Scene Stability', stable,
                `Scene ready: ${sceneReady}, Not disposed: ${sceneNotDisposed}, Camera valid: ${cameraValid}, Target valid: ${cameraTargetValid}`);
        }

        // Test 10: Memory Leaks
        async function testMemoryLeaks() {
            if (!gameWindow.performance || !gameWindow.performance.memory) {
                addTestResult('Memory Leaks', true, 'Memory API not available - skipping test');
                return;
            }

            const initialMemory = gameWindow.performance.memory.usedJSHeapSize;
            
            // Perform multiple camera operations
            for (let i = 0; i < 10; i++) {
                await simulateCameraDragForMemoryTest();
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // Force garbage collection if available
            if (gameWindow.gc) {
                gameWindow.gc();
            }

            await new Promise(resolve => setTimeout(resolve, 1000));

            const finalMemory = gameWindow.performance.memory.usedJSHeapSize;
            const memoryIncrease = finalMemory - initialMemory;
            const memoryIncreasePercent = (memoryIncrease / initialMemory) * 100;

            // Allow up to 10% memory increase as acceptable
            const noSignificantLeak = memoryIncreasePercent < 10;

            addTestResult('Memory Leaks', noSignificantLeak,
                `Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB (${memoryIncreasePercent.toFixed(1)}%)`);
        }

        async function simulateCameraDragForMemoryTest() {
            const gm = gameWindow.gameManager;
            const canvas = gameWindow.document.querySelector('#game-canvas');
            
            if (!canvas) return;

            // Quick camera drag simulation
            const mouseDown = new gameWindow.MouseEvent('mousedown', {
                button: 0, clientX: 400, clientY: 300, bubbles: true
            });
            canvas.dispatchEvent(mouseDown);

            const mouseMove = new gameWindow.MouseEvent('mousemove', {
                button: 0, clientX: 500, clientY: 400, bubbles: true
            });
            gameWindow.document.dispatchEvent(mouseMove);

            const mouseUp = new gameWindow.MouseEvent('mouseup', {
                button: 0, clientX: 500, clientY: 400, bubbles: true
            });
            gameWindow.document.dispatchEvent(mouseUp);
        }
    </script>
</body>
</html>
